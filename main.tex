\documentclass{article}
\usepackage[14pt]{extsizes}
\usepackage[T2A]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{listings}

\begin{document}

\input{title}

\tableofcontents

\newpage

\section{Введение}

Одной из наиболее значимых проблем, стоящих в настоящее время перед производителями и пользователями вычислительных средств, является управление энергопотреблением. Так, плата за энергопотребление мощных серверов, входящих в состав высокопроизводительных вычислительных комплексов (ВК), стала основной статьей затрат на их
обслуживание, а в категории мобильных и встраиваемых систем эффективное управление
энергопотреблением позволяет улучшить одну из главных характеристик – максимальное
время функционирования в автономном режиме (от батареи). В компании ЗАО «МЦСТ»
исследования и разработки, связанные с этой проблемой, начались в 2011 г. в связи с проектированием процессоров для мобильных систем.

Общепринятый подход к снижению уровня энергопотребления сформулирован в
стандарте ACPI, который в ряде распространенных архитектур поддерживается на аппаратном уровне. Согласно этому стандарту для ВК определяется несколько наборов состояния энергосбережения. Наиболее общим является набор {S0;Sn}, характеризующий
энергосберегающие состояния ВК в целом с учетом процессоров, памяти, шин, периферийных устройств. Любое состояние Si из этого набора определяется тремя значениями
(Ci, Pi, Di), каждое из которых принадлежит одному из трех наборов состояний, соответственно {C0;Cn}, {P0;Pn} и {D0;Dn}. Здесь {С0;Сn} – набор состояний сна для процессорного ядра, {P0;Pn} – набор активных состояний с различной частотой для процессорного ядра, {D0;Dn} – набор энергосберегающих состояний шин, памяти, контроллеров
ввода вывода и периферийных устройств, расположенных на материнской плате. В соответствии со стандартом переходы из одного состояния в другое инициируются операционной системой.

В данной работе, построенной на основе проведенных ранее исследований по части
поддержки стандарта ACPI в архитектуре Эльбрус описывается набор состояний С0,С1,С3 и реализация состояния С3.

Система работает под управлением ОС Linux-2.6.33, в ядре которой присутствует
архитектурно-независимая реализация алгоритмов управления энергосбережением, разра-
ботанная силами Linux сообщества. 


\newpage
\subsection{Цель работы}
Снижение энергопотребления ВК на базе микропроцессоров Эльбрус-4С и Эльбрус-8С во время простоя (idle)
\subsection{Задачи}
\begin{itemize}
\item Реализация функциональности перевода вычислительного ядра в состояние глубокого сна
\item Реализация в составе подсистемы cpuidle
\end{itemize}
\subsection{Требования}
Возможность управления через интерфейс sysfs

\newpage
\section{Схема взаимодействия}

\subsection{ACPI}
Усовершенствованный интерфейс управления конфигурацией и питанием

Открытый промышленный стандарт, впервые выпущенный в декабре 1996 года и разработанный совместно компаниями HP, Intel, Microsoft, Phoenix и Toshiba, который определяет общий интерфейс для обнаружения аппаратного обеспечения, управления питанием и конфигурации материнской платы и устройств.

\subsubsection{Состояния центрального процессора}

Стандарт ACPI включает в себя состояния C0, C1, C2, ... , Cn. Где С0 активное состояние при котором центральный процессор выполняет инструкции. Состояния с С1 по Cn это состояния сна потребляющие меньше энергии и рассеивающие меньше тепла. В состоянии сна процессор не выполняет никаких инструкций. Каждое состояние сна имеет задержку, связанную с входом и выходом из этого состояния, что способствует экономии электроэнергии. В целом, чем дольше задержка ввода/вывода, тем больше экономия электроэнергии в этом состоянии. Для экономии электроэнергии, Операционная система размещает ЦП в одно из поддерживаемых состояний во время простоя.

Выделяют три состояния функционирования ядер микропроцессоров семейства Эльбрус
\begin{itemize}
\item С0 – оперативный режим
\item С1 – отключение конвейера
\item С3 – гашения кэш-памятей и отключение синхросигнала (глубокий сон)
\end{itemize}

В ядре ОС Эльбрус нет реализации перехода в состояние С3.

В микропроцессорах семейства Эльбрус есть поддержка подсистемы ядра Linux cpuidle.


\subsection{Cpuidle}
Ядро cpuidle поддерживает отдельно связанные списки всех зарегистрированных драйверов и зарегистрированных говерноров, и обнаруженых устройств(CPU).

Ядро cpuidle имеет обработчик, который подключается к указателю архитектурнонезависимому указателю функции \texttt{pm\_idle}, который будет использоваться каждым отдельным процессором в неактивном состоянии. Перед тем как войти в состояние сна governour выбирает оптимальное состояние. А затем cpuidle вызывает точку входа для этого конкретного состояния в драйвере cpuidle. При возвращении из этого состояния существует необязательный обратный вызов governour для сбора информации о действии в режиме сна.

Число и тип состояний сна могут меняться динамически в зависимости от конкретного состояния данной системы, например от батареи или переменного напряжения. Такое уведомление об изменении состояния системы переходит к драйверу idle, который будет вызывать \texttt{cpuidle\_force\_redetect()} в ядре cpuidle. Это приводит к временному удалению обработчика idle, а также к повторному обнаружению драйвером idle состояния, после чего повторно инициализируется состояние говернора, чтобы принять к сведению это изменение.

Чтобы убедиться в том, что мы не запираем обычную процедуру простоя вход-выход и чтобы безопасно изменить говернор/драйвер во время выполнения, используется \texttt{cpu\_idle\_wait} . Обратите внимание, что изменение драйверов/говерноров является нераспространенным событием, которое не будет учитывать производительность.

Следует ли cpuidle поддерживать один driver и один говернор для всей системы, или же они должны быть для каждого CPU?
С учетом преимуществ сохранения простоты с помощью регулятора и драйвера системного уровня в отношении использования регулятора и драйвера на основе процессора было решено создать единый регулятор и драйвер системного уровня.

Даже несмотря на то, что переключение между губернатором и драйвером может привести к неправильному использованию ендусерс, cpuidle поддерживает переключение времени выполнения губернатором или водителем, главным образом, чтобы помочь разработчикам и тестерам кпуидле. В будущем это переключение драйвера и губернатора может быть отключено по умолчанию, чтобы избежать неправильного использования.

\subsubsection{Интерфейс driver}
\texttt{cpuidle\_register\_driver} использует структуру, определяющая интерфейс драйвера cpuidle:
\lstinputlisting{driver.c}
init() — обратный вызов, вызываемый cpuidle для инициализации каждого устройства в системе с данным конкретным драйвером.

exit() вызывается для выхода из конкретного драйвера для каждого устройства. Обратный вызов redetect() используется для повторного обнаружения состояний устройства, определенных изменений состояния системы.

\texttt{bm\_check()} используется для того, чтобы отметить состояние хозяина шины на устройстве. При init() драйвер должен инициализировать все состояния конкретного устройства и обработать общее количество состояний для этого устройства.

\lstinputlisting{state.c}

enter() — это обратный вызов, используемый для реального ввода этого состояния. \texttt{exit\_latency} и \texttt{power\_usage} являются характеристиками состояния простоя. flags отмечают универсальные возможности, возможности и ошибки состояния бездействия. использование является счетчиком времени, в течение которого вызывается состояние простоя, и время, затраченное на это состояние.

\texttt{cpuidle\_register\_driver()} и \texttt{cpuidle\_unregister\_driver()} используются для регистрации и отмены регистрации (соответственно) драйвера с кпуидле.

\texttt{cpuidle\_force\_detect()} используется водителем для того, чтобы заставить кпуидле ядро повторно обнаружить все состояния устройств (например, после изменения состояния системы).

\subsubsection{Интерфейс governour}
\lstinputlisting{governour.c}

init() — обратный вызов, вызванный cpuidle, для инициализации каждого governour с определенным устройством. exit() вызывается для выхода из этого governour для устройства.

scan() вызывается при повторном обнаружении состояний устройства. Это дает governour возможность отметить изменения в states во время повторного обнаружения driver.

select() вызывается перед каждой записью бездействующего устройства, чтобы governour мог сделать выбор состояния для для бездействующего вызова. reflect() вызывается после выхода из idle, чтобы governour мог захватить информацию о проживании в режиме idle. Обратите внимание, что время, затраченное в функции reflect() говернора, находится в критическом пути (при выходе из idle, до начала работы) и, следовательно, должно быть быстрым.

\texttt{cpuidle\_register\_governor()}  и \texttt{cpuidle\_unregister\_governor()} используются для регистрации и отмены регистрации (соответственно) governour с cpuid

\texttt{cpuidle\_get\_bm\_activity()} получает информацию о деятельности bm, которая может использоваться governour во время процедуры select.

\subsubsection{Device}
Структура содержит информацию о количестве состояний бездействия, которые поддерживаются каждым процессором, информацию о каждом из этих состояний (в массиве ) а также о состоянии этого устройства(CPU).
\lstinputlisting{device.c}

\subsection{Интерфейс userspace}

Следующая информация находится в /sys/devices/system/cpu/cpuidle/.

\texttt{available\_drivers} — это интерфейс только для чтения, в котором перечислены все драйверы, успешно зарегистрированные в cpuidle.

\texttt{current\_driver} — это интерфейс для чтения и записи, содержащий текущий активный cpuidle driver. Записывая новое значение в этот интерфейс, можно изменить драйвер бездействующего времени во время выполнения.

\texttt{available\_governors} является интерфейсом только для чтения, в котором перечислены все губернаторы, успешно зарегистрированные в cpuidle.

\texttt{current\_governor} — это интерфейс для чтения и записи, содержащий текущий активный cpuidle governor. Записывая новое значение этому интерфейсу, governor idle может быть изменен во время выполнения.

Примечание для всех процессоров в системе может быть один governor и один driver.

Следующая информация находится в /sys/devices/system/cpu/cpuX/cpuidle/ где X = 0, 1, 2,.... Для каждого состояния idle, поддерживаемого текущим драйвером, можно увидеть следующую информацию только для чтения под sysfs.

stateY/usage: показывает число случаев, когда это состояние idle было введено с момента init или redetect.

stateY/time: показывает время, затраченное на это состояние простоя в микросекундах. 

stateY/latency: показывает задержку пробуждения для данного состояния.

stateY/power: показывает типичную потребляемую мощность при входе ЦП в это состояние в МВт.


\subsection{Алгоритм выбора состояния сна}
Выбор оптимального состояния сна зависит от статистики интервалов простоя и загруженности процессора. Оптимальным выбором будем считать состояние, переход в которое не влияет на среднюю производительность операционной системы при заданной загрузке вычислительного комплекса процессами пользователя.
Алгоритм выбора состояния сна, используемый в Linux, основан на анализе четырех
факторов:
1) duration – предсказание времени нахождения процессорного ядра в состоянии
простоя;
2) correction – коэффициент поправки предсказания, вычисленный на основе статистики прихода внешних прерываний;
3) latency – значение времени выхода из состояния сна;
4) \texttt{latency\_mutliplier} – множитель для значения latency рассчитанный с использованием средней загруженности процессорного ядра.
9
Для принятия решения алгоритм в цикле рассматривает все состояния сна, начиная с
С3, на каждой итерации проверяя условие:
((latency * \texttt{latency\_mutiplier}) < (duration * correction)).
Если условие справедливо, то выполняется выход из цикла, и управление передается
драйверу PMC, который переводит процессор в выбранное состояние сна.
Заданные в неравенстве величины вычисляются следующим образом. Значение
duration рассчитывается исходя из интервала времени, на которое установлен таймеристочник внешних прерываний для планировщика процессов [7]. Это оптимистичное
предсказание времени нахождения процессорного ядра в состоянии простоя. Для того
чтобы сделать его более реальным, на основе статистики прихода внешних прерываний
рассчитывается коэффициент correction как скользящее среднее от отношения фактического значения времени сна к оптимистической оценке, вычисленного при предыдущем
простое. Если на предыдущем шаге простой продлился 50\% от оптимистической оценки,
то при вычислении скользящего среднего будет использован коэффициент 0,5. Значение
времени выхода из состояния сна latency является константой, которая задается при инициализации драйвера PMC и фиксирована для каждого аппаратно-поддержанного состояния сна. Множитель \texttt{latency\_multiplier} рассчитывается исходя из текущего состояния
средней загруженности процессорного ядра \texttt{load\_average} согласно эвристическому прави-
лу:
\texttt{latency\_multiplier} = (\texttt{load\_average} * 10) + (\texttt{num\_iowaiters} * 5),
где \texttt{num\_iowaiters} – количество процессов, ожидающих на данном процессорном ядре завершения обмена с устройством IO.
Описанный алгоритм является адаптивным и способен выбирать состояние глубоко-
го сна при слабой нагрузке вычислительного комплекса, минимизируя количество пере-
ключений в одно из состояний сна при высокой нагрузке.


\subsection{Ladder и Menu}

Говернор ladder принимает поэтапный подход к выбору состояния простоя. Несмотря на то, что это работает с периодическими ядрами на основе тактов, эта модель Step-WISE не будет работать очень хорошо с ядрами. Ядро может просто простаивать на протяжении длительного времени без периодического таймера, и это может не получить возможности пошаговой вниз по лестнице в состояние глубокого бездействующего состояния при простое.

В настоящее время ведется работа над новым регулятором бездействующего, который называется губернатором меню. Губернатор меню смотрит на различные параметры, такие как ожидаемое время сна (как показано на динтикк), требования к задержке, предыдущее состояние \texttt{C\-state}, \texttt{max\_cstate} требование, действие BM и т. д. Этот губернатор стремится получить максимальные преимущества, не влияющие на производительность.

Коцепции и идеи лежащие в menu

Существуют три фактора принятия решения
1) Разрыв энергии
2) Влияние производительности
3) Допустимая задержка
Эти факторы рассматриваются независимо

Вход и выход из состояния C имеют некую стоимость энергии, и требуется определенное количество времени для фактического достижения этой стоимости. CPUIDLE предоставляет нам эту продолжительность в поле «\texttt{target\_residency}». Итак, все, что нам нужно, - это хорошее предсказание того, как долго мы будем простаивать. Как и традиционный governor menu, мы начинаем с фактического времени «следующего события таймера».

Поскольку есть другой источник пробуждений (например, прерывания), чем следующий случай таймера, эта оценка довольно оптимистична. Чтобы получить более реалистичную оценку, применяется поправочный коэффициент, основанный на историческом поведении. Например, если в прошлом фактическая продолжительность всегда составляла 50\% от следующего таймера, поправочный коэффициент будет равен 0,5.

В menu используется среднее значение для этого поправочного коэффициента, однако он использует не один фактор, а целый набор факторов. Это связано с тем, что отношение зависит от порядка величины ожидаемой продолжительности; Если мы ожидаем 500 миллисекунд простоя, вероятность очень рано получить прерывание , намного выше, чем если бы мы ожидали 50 микросекунд простоя. Второй независимый фактор, который оказывает большое влияние на фактический фактор, - это если есть (диск) IO выдающийся или нет. (В качестве особого поворота мы рассматриваем каждый сон продолжительностью более 50 миллисекунд как идеальный, нет увеличения мощности для сна дольше, чем это)

По этим двум причинам мы держим массив из 12 независимых факторов, который получает
Индексированных в зависимости от величины ожидаемой продолжительности, а также
«Является IO выдающейся» собственностью.

Повторяющийся интервал-детектор
Существуют случаи, когда «следующий таймер» является полностью непригодным для использования предиктором: те случаи, когда интервал фиксирован, например, из-за уменьшения аппаратного прерывания, а также из-за устройств с фиксированной скоростью передачи, таких как мыши.
Для этого мы используем другой предиктор: мы отслеживаем длительность последних 8 интервалов, и если отклонение в стойке этих 8 интервалов ниже порогового значения, мы используем среднее значение этих интервалов в качестве предсказания.

Ограничение производительности

Состояния сна, особенно те, у кого большие задержки при выходе, могут иметь реальное заметное влияние на рабочие нагрузки, что неприемлемо для большинства системных администраторов, и, кроме того, меньшая производительность имеет свою собственную цену.
Как правило, меню предполагает, что выполняется следующая эвристика:

Чем больше нагружена система, тем меньше влияние C-состояний приемлемо

Это правило большого пальца реализовано с использованием мультипликатора производительности. Если время ожидания выхода превышает мультипликатор производительности больше, чем предсказанная продолжительность, состояние C не считается кандидатом на выбор из-за слишком высокого воздействия на производительность. Таким образом, чем выше этот множитель, тем дольше нам нужно простаивать, чтобы выбрать глубокое состояние C, и, следовательно, чем меньше вероятность того, что занятый CPU попадет в такое глубокое состояние C.

Для определения этого множителя используются два фактора: для каждой точки «среднего значения нагрузки на процессор» мы добавляем значение 10.
Для каждого процесса, ожидающего ввода-вывода на этом CPU, добавляется значение 5 баллов. (Эти значения экспериментально определены)

Среднее значение нагрузки дает более долгосрочный (несколько секунд) вход для решения, в то время как значение iowait дает локальный мгновенный вход cpu. Коэффициент iowait может выглядеть низким, но поймите, что это также уже представлено в средстве загрузки системы.


\newpage
\section{Детали реализаци}

\subsection{Алгоритм отключения ядра}

Фрагмент кода, приводящий к выключению синхронизации вычислительного ядра,
должен соответствовать нижеперечисленным правилам, иначе возможна подмена данных
или "зависание" ядра или даже всей машины.

1) Код выключения ядра должен быть резидентным как в физической, так и в виртуальной памяти.

2) Код выключения ядра должен быть немодифицируемым.

3) Код выключения ядра исполняется на том же ядре.

4) Код выключения ядра не должен содержать операций обращения в память, за
исключением приведенных ниже спецопераций.

5) Код выключения ядра не должен содержать операций подготовки перехода и
предподкачки кода.

6) Код выключения ядра должен содержать инвалидацию регистров подготовки
перехода. Это позволяет избежать слабоконтролируемых спекулятивных обращений в
память от незавершенных операций подготовки перехода.

7) Код выключения ядра должен содержать операции гашения кэшей процессора:

	- операция очистки всего кэша данных (см. C.20.2);
	       - операция очистки всего кэша команд (см. C.20.4);
	      - операция очистки всего TLB (см. C.20.7);
Это позволяет избавиться от данных и трансляций, которые могут устареть пока
ядро выключено и не может реагировать на внешние события (например,
снупирование).

8) Перед исполнением операции выключения ядра весь фрагмент кода, приводящий к
выключению, должен быть подкачен в буфер команд. Это позволяет избежать
слабоконтролируемых спекулятивных обращений в память от незавершенной
предподкачки прямой ветви кода. Это требование предполагает двойной проход по
части кода, причем первый раз исполнительные операции пропускаются, а
исполняются только во время второго прохода.

9) Перед исполнением операции выключения ядра нужно дождаться завершения
активности подсистемы памяти. Для этого служит команда {}.

\newpage
\lstinputlisting{e2k_clk_off.c}

\newpage
\section{Заключение}

\section{Результаты}

\newpage
\section{Список литературы}


\end{document}




