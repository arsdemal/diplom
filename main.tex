\documentclass{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{listings}

\begin{document}

\input{title}

\tableofcontents

\newpage

\section{Введение}

Характеристики энергопотребления микропроцессоров семейства «Эльбрус»
являются одним из важнейших факторов при создании вычислительных комплексов (ВК)
на их основе.

Основную часть управления электропитанием процессоров в операционной системе Linux берет на себя cpufreq, который изменяет частоту и уровень производительности процессора в зависимости от нагрузки процессора.

Еще одной важной деталью энергосбережения является мощность процессора в режиме холостого хода.

\subsection{Цель работы}
Снижение энергопотребления ВК на базе микропроцессоров Эльбрус-4С и Эльбрус-8С во время простоя (idle)
\subsection{Задачи}
Реализовать в драйвере cpuidle-e2k функциональность перевода вычислительного ядра в состояние глубокого сна
\subsection{Требования}
Управление подсистемой посредством команд

\newpage
\section{Схема взаимодействия}

\subsection{ACPI}
Усовершенствованный интерфейс управления конфигурацией и питанием

Открытый промышленный стандарт, впервые выпущенный в декабре 1996 года и разработанный совместно компаниями HP, Intel, Microsoft, Phoenix и Toshiba, который определяет общий интерфейс для обнаружения аппаратного обеспечения, управления питанием и конфигурации материнской платы и устройств.

\subsubsection{Состояния центрального процессора}

Стандарт ACPI включает в себя состояния C0, C1, C2, ... , Cn. Где С0 активное состояние при котором центральный процессор выполняет инструкции. Состояния с С1 по Cn это состояния сна потребляющие меньше энергии и рассеивающие меньше тепла. В состоянии сна процессор не выполняет никаких инструкций. Каждое состояние сна имеет задержку, связанную с входом и выходом из этого состояния, что способствует экономии электроэнергии. В целом, чем дольше задержка ввода/вывода, тем больше экономия электроэнергии в этом состоянии. Для экономии электроэнергии, Операционная система размещает ЦП в одно из поддерживаемых состояний во время простоя.

В микропроцессорах семейства Эльбрус есть поддержка подсистемы ядра Linux cpuidle.


\subsection{Cpuidle}
Ядро cpuidle поддерживает отдельно связанные списки всех зарегистрированных драйверов и зарегистрированных говерноров, и обнаруженых устройств(CPU).

Ядро cpuidle имеет обработчик, который подключается к указателю архитектурнонезависимому указателю функции \texttt{pm\_idle}, который будет использоваться каждым отдельным процессором в неактивном состоянии. Перед тем как войти в состояние сна governour выбирает оптимальное состояние. А затем cpuidle вызывает точку входа для этого конкретного состояния в драйвере cpuidle. При возвращении из этого состояния существует необязательный обратный вызов говернора для сбора информации о действии в режиме сна.

Число и тип состояний сна могут меняться динамически в зависимости от конкретного состояния данной системы, например от батареи или переменного напряжения. Такое уведомление об изменении состояния системы переходит к драйверу idle, который будет вызывать 
\texttt{cpuidle\_force\_redetect()} в ядре cpuidle. Это приводит к временному удалению обработчика idle, а также к повторному обнаружению драйвером idle состояния, после чего повторно инициализируется состояние говернора, чтобы принять к сведению это изменение.

Чтобы убедиться в том, что мы не запираем обычную процедуру простоя вход-выход и чтобы безопасно изменить говернор/драйвер во время выполнения, используется \texttt{cpu\_idle\_wait} . Обратите внимание, что изменение драйверов/говерноров является нераспространенным событием, которое не будет учитывать производительность.

Следует ли cpuidle поддерживать один driver и один говернор для всей системы, или же они должны быть для каждого CPU?
С учетом преимуществ сохранения простоты с помощью регулятора и драйвера системного уровня в отношении использования регулятора и драйвера на основе процессора было решено создать единый регулятор и драйвер системного уровня.

Даже несмотря на то, что переключение между губернатором и драйвером может привести к неправильному использованию ендусерс, кпуидле поддерживает переключение времени выполнения губернатором или водителем, главным образом, чтобы помочь разработчикам и тестерам кпуидле. В будущем это переключение драйвера и губернатора может быть отключено по умолчанию, чтобы избежать неправильного использования.

\subsubsection{Интерфейс driver}
\texttt{cpuidle\_register\_driver} использует структуру, определяющая интерфейс драйвера cpuidle:
\lstinputlisting{driver.c}
init() — обратный вызов, вызываемый cpuidle для инициализации каждого устройства в системе с данным конкретным драйвером.

exit() вызывается для выхода из конкретного драйвера для каждого устройства. Обратный вызов redetect() используется для повторного обнаружения состояний устройства, определенных изменений состояния системы.

\texttt{bm\_check()} используется для того, чтобы отметить состояние хозяина шины на устройстве. При init() драйвер должен инициализировать все состояния конкретного устройства и обработать общее количество состояний для этого устройства.

\lstinputlisting{state.c}

enter() — это обратный вызов, используемый для реального ввода этого состояния. \texttt{exit\_latency} и \texttt{power\_usage} являются характеристиками состояния простоя. flags отмечают универсальные возможности, возможности и ошибки состояния бездействия. использование является счетчиком времени, в течение которого вызывается состояние простоя, и время, затраченное на это состояние.

\texttt{cpuidle\_register\_driver()} и \texttt{cpuidle\_unregister\_driver()} используются для регистрации и отмены регистрации (соответственно) драйвера с кпуидле.

\texttt{cpuidle\_force\_detect()} используется водителем для того, чтобы заставить кпуидле ядро повторно обнаружить все состояния устройств (например, после изменения состояния системы).

\subsubsection{Интерфейс governour}
\lstinputlisting{governour.c}

init() — обратный вызов, вызванный cpuidle, для инициализации каждого governour с определенным устройством. exit() вызывается для выхода из этого governour для устройства.

scan() вызывается при повторном обнаружении состояний устройства. Это дает governour возможность отметить изменения в states во время повторного обнаружения driver.

select() вызывается перед каждой записью бездействующего устройства, чтобы governour мог сделать выбор состояния для для бездействующего вызова. reflect() вызывается после выхода из idle, чтобы governour мог захватить информацию о проживании в режиме idle. Обратите внимание, что время, затраченное в функции reflect() говернора, находится в критическом пути (при выходе из idle, до начала работы) и, следовательно, должно быть быстрым.

\texttt{cpuidle\_register\_governor()}  и \texttt{cpuidle\_unregister\_governor()} используются для регистрации и отмены регистрации (соответственно) governour с cpuid

\texttt{cpuidle\_get\_bm\_activity()} получает информацию о деятельности bm, которая может использоваться governour во время процедуры select.

\subsubsection{Device}
Структура содержит информацию о количестве состояний бездействия, которые поддерживаются каждым процессором, информацию о каждом из этих состояний (в массиве ) а также о состоянии этого устройства(CPU).
\lstinputlisting{device.c}

\subsection{Интерфейс userspace}

Следующая информация находится в /sys/devices/system/cpu/cpuidle/.

\texttt{available\_drivers} — это интерфейс только для чтения, в котором перечислены все драйверы, успешно зарегистрированные в cpuidle.

\texttt{current\_driver} — это интерфейс для чтения и записи, содержащий текущий активный cpuidle driver. Записывая новое значение в этот интерфейс, можно изменить драйвер бездействующего времени во время выполнения.

\texttt{available\_governors} является интерфейсом только для чтения, в котором перечислены все губернаторы, успешно зарегистрированные в cpuidle.

\texttt{current\_governor} — это интерфейс для чтения и записи, содержащий текущий активный cpuidle governor. Записывая новое значение этому интерфейсу, governor idle может быть изменен во время выполнения.

Примечание для всех процессоров в системе может быть один governor и один driver.

Следующая информация находится в /sys/devices/system/cpu/cpuX/cpuidle/ где X = 0, 1, 2,.... Для каждого состояния idle, поддерживаемого текущим драйвером, можно увидеть следующую информацию только для чтения под sysfs.

stateY/usage: показывает число случаев, когда это состояние idle было введено с момента init или redetect.

stateY/time: показывает время, затраченное на это состояние простоя в микросекундах. 

stateY/latency: показывает задержку пробуждения для данного состояния.

stateY/power: показывает типичную потребляемую мощность при входе ЦП в это состояние в МВт.

\subsection{Ladder и Menu}

Говернор ladder принимает поэтапный подход к выбору состояния простоя. Несмотря на то, что это работает с периодическими ядрами на основе тактов, эта модель Step-WISE не будет работать очень хорошо с ядрами. Ядро может просто простаивать на протяжении длительного времени без периодического таймера, и это может не получить возможности пошаговой вниз по лестнице в состояние глубокого бездействующего состояния при простое.

В настоящее время ведется работа над новым регулятором бездействующего, который называется губернатором меню. Губернатор меню смотрит на различные параметры, такие как ожидаемое время сна (как показано на динтикк), требования к задержке, предыдущее состояние \texttt{C\-state}, \texttt{max\_cstate} требование, действие BM и т. д. Этот губернатор стремится получить максимальные преимущества, не влияющие на производительность.

\newpage
\section{Детали реализаци}

\subsection{Алгоритм отключения ядра}

Фрагмент кода, приводящий к выключению синхронизации вычислительного ядра,
должен соответствовать нижеперечисленным правилам, иначе возможна подмена данных
или "зависание" ядра или даже всей машины.

1) Код выключения ядра должен быть резидентным как в физической, так и в виртуальной памяти.

2) Код выключения ядра должен быть немодифицируемым.

3) Код выключения ядра исполняется на том же ядре.

4) Код выключения ядра не должен содержать операций обращения в память, за
исключением приведенных ниже спецопераций.

5) Код выключения ядра не должен содержать операций подготовки перехода и
предподкачки кода.

6) Код выключения ядра должен содержать инвалидацию регистров подготовки
перехода. Это позволяет избежать слабоконтролируемых спекулятивных обращений в
память от незавершенных операций подготовки перехода.

7) Код выключения ядра должен содержать операции гашения кэшей процессора:

	- операция очистки всего кэша данных (см. C.20.2);
	       - операция очистки всего кэша команд (см. C.20.4);
	      - операция очистки всего TLB (см. C.20.7);
Это позволяет избавиться от данных и трансляций, которые могут устареть пока
ядро выключено и не может реагировать на внешние события (например,
снупирование).

8) Перед исполнением операции выключения ядра весь фрагмент кода, приводящий к
выключению, должен быть подкачен в буфер команд. Это позволяет избежать
слабоконтролируемых спекулятивных обращений в память от незавершенной
предподкачки прямой ветви кода. Это требование предполагает двойной проход по
части кода, причем первый раз исполнительные операции пропускаются, а
исполняются только во время второго прохода.

9) Перед исполнением операции выключения ядра нужно дождаться завершения
активности подсистемы памяти. Для этого служит команда {}.

\newpage
\lstinputlisting{e2k_clk_off.c}

\subsection{Проблемы}

\newpage
\section{Заключение}

\section{Результаты}

\newpage
\section{Список литературы}


\end{document}




