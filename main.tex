\documentclass{article}
\usepackage[14pt]{extsizes}
\linespread{1.3}
\usepackage[T2A]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{listings}
\usepackage{graphicx}
\righthyphenmin=2

\begin{document}

\input{title}

\tableofcontents

\newpage

\section{Введение}

Одной из наиболее значимых проблем, стоящих в настоящее время перед производителями и пользователями вычислительных средств, является управление энергопотреблением. Так, плата за энергопотребление мощных серверов, входящих в состав высокопроизводительных вычислительных комплексов (ВК), стала основой затрат на их обслуживание, а в категории мобильных и встраиваемых систем эффективное управление энергопотреблением позволяет улучшить одну из главных характеристик --- максимальное время функционирования в автономном режиме (от батареи). В компании ЗАО «МЦСТ» исследования и разработки, связанные с этой проблемой, начались в 2011 г. в связи с проектированием процессоров для мобильных систем.

В данной работе, построенной на основе проведенных ранее исследований по части
поддержки стандарта ACPI в архитектуре Эльбрус описывается набор состояний С0,С1,С3 и реализация состояния С3 для микропроцессоров Эльбрус--4С и Эльбрус--8С.

Система работает под управлением ОС Linux-2.6.33, в ядре которой присутствует
архитектурно-независимая реализация алгоритмов управления энергосбережением, разра-
ботанная силами Linux сообщества. 

\subsection{Цель работы}
Снижение энергопотребления ВК на базе \\ микропроцессоров Эльбрус--4С и Эльбрус--8С во время простоя (idle)
\subsection{Задачи}
\begin{itemize}
\item Реализация функциональности перевода вычислительного ядра в состояние глубокого сна
\item Реализация в составе подсистемы cpuidle
\end{itemize}
\subsection{Требования}
Возможность управления через интерфейс sysfs


\newpage
\section{Состояния ядер микропроцессора}

Общепринятый подход к снижению уровня энергопотребления сформулирован в стандарте ACPI, который в ряде распространенных архитектур поддерживается на аппаратном уровне. Согласно этому стандарту для ВК определяется несколько наборов состояния энергосбережения. Наиболее общим является набор {S0;Sn}, характеризующий энергосберегающие состояния ВК в целом с учетом процессоров, памяти, шин, периферийных устройств. Любое состояние Si из этого набора определяется тремя значениями (Ci, Pi, Di), каждое из которых принадлежит одному из трех наборов состояний, соответственно {C0;Cn}, {P0;Pn} и {D0;Dn}. Здесь {С0;Сn} – набор состояний сна для процессорного ядра, {P0;Pn} – набор активных состояний с различной частотой для процессорного ядра, {D0;Dn} – набор энергосберегающих состояний шин, памяти, контроллеров ввода вывода и периферийных устройств, расположенных на материнской плате. В соответствии со стандартом, переходы из одного состояния в другое инициируются операционной системой.

\subsection{Состояния сна}

Как было сказано выше стандарт ACPI включает в себя состояния C0, C1, C2, ... , Cn. Где С0 активное состояние при котором центральный процессор выполняет инструкции. Состояния с С1 по Cn это состояния сна потребляющие меньше энергии и рассеивающие меньше тепла. В состоянии сна процессор не выполняет никаких инструкций. Каждое состояние сна имеет задержку, связанную с входом и выходом из этого состояния, что способствует экономии электроэнергии. В целом, чем дольше задержка ввода/вывода, тем больше экономия электроэнергии в этом состоянии. Для экономии электроэнергии, операционная система размещает ЦП в одно из поддерживаемых состояний во время простоя.

Выделяют три состояния функционирования ядер микропроцессоров семейства Эльбрус
\begin{itemize}
\item С0 – оперативный режим
\item С1 – отключение конвейера
\item С3 – гашения кэш-памятей и отключение синхросигнала (глубокий сон)
\end{itemize}

Следует отметить, что в ядре ОС Эльбрус нет реализации перехода в состояние С3.


\newpage
\section{Перевод вычислительного ядра в С3 }

\subsection{Описание алгоритма}

Фрагмент кода, приводящий к выключению синхронизации вычислительного ядра,
должен соответствовать нижеперечисленным правилам, иначе возможна подмена данных
или "зависание" ядра или даже всей машины.

1) Код выключения ядра должен быть резидентным как в физической, так и в виртуальной памяти.

2) Код выключения ядра должен быть немодифицируемым.

3) Код выключения ядра исполняется на том же ядре.

4) Код выключения ядра не должен содержать операций обращения в память, за
исключением приведенных ниже спецопераций.

5) Код выключения ядра не должен содержать операций подготовки перехода и
предподкачки кода.

6) Код выключения ядра должен содержать инвалидацию регистров подготовки
перехода. Это позволяет избежать слабоконтролируемых спекулятивных обращений в
память от незавершенных операций подготовки перехода.

7) Код выключения ядра должен содержать операции гашения кэшей процессора:

	- операция очистки всего кэша данных (см. C.20.2);
	       - операция очистки всего кэша команд (см. C.20.4);
	      - операция очистки всего TLB (см. C.20.7);
Это позволяет избавиться от данных и трансляций, которые могут устареть пока
ядро выключено и не может реагировать на внешние события (например,
снупирование).

8) Перед исполнением операции выключения ядра весь фрагмент кода, приводящий к
выключению, должен быть подкачен в буфер команд. Это позволяет избежать
слабоконтролируемых спекулятивных обращений в память от незавершенной
предподкачки прямой ветви кода. Это требование предполагает двойной проход по
части кода, причем первый раз исполнительные операции пропускаются, а
исполняются только во время второго прохода.

9) Перед исполнением операции выключения ядра нужно дождаться завершения
активности подсистемы памяти. Для этого служит команда {}.

Алгоритм реализован в функции \texttt{e2k\_enter\_idle()}.\\ 
Функция входит в состав интерфейса \texttt{e2k\_idle\_driver}.

\newpage
\section{Встраивание в подсистему cpuidle}



\subsection{Общая схема}

Cpuidle --- подсистема ядра Linux, переводящая ядра микропроцесора в различные состояния сна в состоянии простоя процессора.

%\includegraphics[scale=0.5]{01}
Сpuidle core поддерживает отдельно связанные списки всех \\ зарегистрированных driver и зарегистрированных governor, и обнаруженых устройств(CPU).

Сpuidle core имеет обработчик idle (простоя), \texttt{cpuidle\_idle\_call()} , который подключается к архитектурнонезависимому указателю функции \texttt{pm\_idle}, который будет использоваться каждым отдельным процессором в неактивном состоянии. Перед тем как войти в состояние сна, governor выбирает оптимальное состояние. А затем cpuidle вызывает точку входа для этого конкретного состояния в driver. При возвращении из этого состояния существует необязательный обратный вызов governor для сбора информации о действии в состоянии сна.

Число и тип состояний сна могут меняться динамически в зависимости от конкретного состояния данной системы, например от батареи или переменного напряжения. Такое уведомление об изменении состояния системы переходит к driver, который будет вызывать \texttt{cpuidle\_force\_redetect()} в ядре cpuidle. Это приводит к временному удалению обработчика idle, а также к повторному обнаружению driver idle состояния, после чего повторно инициализируется состояние governor, чтобы принять к сведению это изменение.

Чтобы убедиться в том, что мы не запираем обычную процедуру простоя вход/выход и чтобы безопасно изменить governor/driver во время выполнения, используется \texttt{cpu\_idle\_wait} . Обратите внимание, что изменение driver/governor является нераспространенным событием, которое не будет учитывать производительность.

Следует ли cpuidle поддерживать один driver и один governor для всей системы, или же они должны быть для каждого CPU? С учетом простоты реализации governor и driver на программном уровне, в отличие от аппаратного, было решено создать единый driver и governor на программном уровне.

Даже несмотря на то, что переключение между governor и driver может привести к неправильному использованию конечным пользователем, cpuidle поддерживает переключение времени выполнения governor или driver, главным образом, чтобы помочь разработчикам и тестерам cpuidle. В будущем это переключение driver и governor может быть отключено по умолчанию, чтобы избежать неправильного использования.

\subsection{Интерфейс driver}
\texttt{cpuidle\_register\_driver} использует структуру, определяющую интерфейс драйвера cpuidle:
\lstinputlisting{driver.c}
init() --- обратный вызов, вызываемый cpuidle для инициализации каждого устройства в системе с данным driver.

exit() вызывается для выхода из конкретного driver для каждого устройства. Обратный вызов redetect() используется для повторного обнаружения состояний устройства, определенных изменений состояния системы.

При init() driver должен инициализировать все состояния конкретного устройства и обработать общее количество состояний для этого устройства.

\lstinputlisting{state.c}

enter() --- это обратный вызов, используемый для непосредственного перевода ядра процессора в состояние сна. \texttt{exit\_latency} и \texttt{power\_usage} являются характеристиками состояния простоя. flags отмечают универсальные возможности и ошибки состояния бездействия. usage является счетчиком времени, в течение которого вызывается состояние сна, а \\time --- время затраченное на это состояние.

\texttt{cpuidle\_register\_driver()} и \texttt{cpuidle\_unregister\_driver()} используются для регистрации и отмены регистрации (соответственно) driver с cpuidle.

\texttt{cpuidle\_force\_detect()} используется driver для того, чтобы заставить cpuidle core повторно обнаружить все состояния устройств (например, после изменения состояния системы).

\subsection{Интерфейс governour}
\lstinputlisting{governour.c}

init() --- обратный вызов, вызванный cpuidle, для инициализации каждого governour с устройством (CPU). exit() вызывается для выхода устройства из этого governour.

scan() вызывается при повторном обнаружении состояний устройства. Это дает governour возможность отметить изменения в states во время повторного обнаружения driver.

select() вызывается перед каждым вхождением устройства в состояние сна, чтобы governour мог сделать выбор состояния для вызова idle. reflect() вызывается после выхода из idle, чтобы governour мог захватить информацию о ядре находившемся в этом состоянии. Обратите внимание, что время, затраченное в функции reflect() governor, находится в критическом пути (при выходе из idle, до начала работы) и, следовательно, должно быть быстрым.

\texttt{cpuidle\_register\_governor()}  и \texttt{cpuidle\_unregister\_governor()} используются для регистрации и отмены регистрации (соответственно) governour с cpuidle.

\texttt{cpuidle\_get\_bm\_activity()} получает информацию о деятельности bm, которая может использоваться governour во время процедуры select.

\subsubsection{Реализации}

На данный момент существуют две реализации governor.

Governor ladder принимает поэтапный подход к выбору состояния сна. Несмотря на то что, эта политка хорошо работает на ядрах процессора с периодическими тактами, она будет плохо себя вести на бестактных (непериодические такты) ядрах. Ядро может оставаться в состоянии сна долгое время без периодических тактов, и у ядра не будет возможности перейти в более глубокий сон

В настоящее время ведется работа над новым governor, который называется menu. Governor menu смотрит на различные параметры, такие как ожидаемое время сна, требования к задержке, предыдущее состояние сна и т. д. Этот governor стремится получить максимальные преимущества, не влияющие на производительность.

\subsubsection{Алгоритм выбора состояния сна}

Коцепции и идеи лежащие в menu

Существуют три фактора принятия решения
1) Покрытие расходов 
2) Влияние производительности
3) Допустимая задержка
Эти факторы рассматриваются независимо

Вход и выход из состояния сна требуют некоторое количество энергии и для того, чтобы покрыть эти расходы, нужно определенное количество времени нахождения в этом состоянии. Cpuidle core предоставляет нам эту продолжительность в поле «\texttt{target\_residency}». Итак, все, что нам нужно, - это хорошее предсказание того, как долго мы будем простаивать. Как и традиционный governor menu, мы начинаем с фактического времени «следующего события таймера».

Поскольку есть другой источник пробуждений (например, прерывания), чем следующий случай таймера, эта оценка довольно оптимистична. Чтобы получить более реалистичную оценку, применяется поправочный коэффициент, основанный на предыдущем поведении. Например, если в прошлом фактическая продолжительность всегда составляла 50\% от следующего таймера, поправочный коэффициент будет равен 0,5.

В menu используется среднее значение для этого поправочного коэффициента, однако он использует не один фактор, а целый набор факторов. Это связано с тем, что отношение зависит от порядка величины ожидаемой продолжительности; Если мы ожидаем 500 миллисекунд простоя, вероятность очень рано получить прерывание , намного выше, чем если бы мы ожидали 50 микросекунд простоя. Второй независимый фактор, который оказывает большое влияние на фактический фактор, - это если есть (диск) IO выдающийся или нет. (В качестве особого поворота мы рассматриваем каждый сон продолжительностью более 50 миллисекунд как идеальный, нет увеличения мощности для сна дольше, чем это)

По этим двум причинам мы используем массив из 12 независимых факторов, который получает
Индексированных в зависимости от величины ожидаемой продолжительности, а также
«Является IO выдающейся» собственностью.

Повторяющийся интервал-детектор
Существуют случаи, когда «следующий таймер» является полностью непригодным для использования предиктором: те случаи, когда интервал фиксирован, например, из-за уменьшения аппаратного прерывания, а также из-за устройств с фиксированной скоростью передачи, таких как мыши.
Для этого мы используем другой предиктор: мы отслеживаем длительность последних 8 интервалов, и если отклонение в стойке этих 8 интервалов ниже порогового значения, мы используем среднее значение этих интервалов в качестве предсказания.

Ограничение производительности

Состояния сна, особенно те, у кого большие задержки при выходе, могут иметь реальное заметное влияние на рабочие нагрузки, что неприемлемо для большинства системных администраторов, и, кроме того, меньшая производительность имеет свою собственную цену.
Как правило, меню предполагает, что выполняется следующая эвристика:

Чем больше нагружена система, тем меньше влияние C-состояний приемлемо

Это правило большого пальца реализовано с использованием мультипликатора производительности. Если время ожидания выхода превышает мультипликатор производительности больше, чем предсказанная продолжительность, состояние C не считается кандидатом на выбор из-за слишком высокого воздействия на производительность. Таким образом, чем выше этот множитель, тем дольше нам нужно простаивать, чтобы выбрать глубокое состояние C, и, следовательно, чем меньше вероятность того, что занятый CPU попадет в такое глубокое состояние C.

Для определения этого множителя используются два фактора: для каждой точки «среднего значения нагрузки на процессор» мы добавляем значение 10.
Для каждого процесса, ожидающего ввода-вывода на этом CPU, добавляется значение 5 баллов. (Эти значения экспериментально определены)

Среднее значение нагрузки дает более долгосрочный (несколько секунд) вход для решения, в то время как значение iowait дает локальный мгновенный вход cpu. Коэффициент iowait может выглядеть низким, но поймите, что это также уже представлено в средстве загрузки системы.

Выбор оптимального состояния сна зависит от статистики интервалов простоя и загруженности процессора. Оптимальным выбором будем считать состояние, переход в которое не влияет на среднюю производительность операционной системы при заданной загрузке вычислительного комплекса процессами пользователя.
Алгоритм выбора состояния сна, используемый в Linux, основан на анализе четырех
факторов:
1) duration – предсказание времени нахождения процессорного ядра в состоянии
простоя;
2) correction – коэффициент поправки предсказания, вычисленный на основе статистики прихода внешних прерываний;
3) latency – значение времени выхода из состояния сна;
4) \texttt{latency\_mutliplier} – множитель для значения latency рассчитанный с использованием средней загруженности процессорного ядра.
9
Для принятия решения алгоритм в цикле рассматривает все состояния сна, начиная с
С3, на каждой итерации проверяя условие:
((latency * \texttt{latency\_mutiplier}) < (duration * correction)).
Если условие справедливо, то выполняется выход из цикла, и управление передается
драйверу PMC, который переводит процессор в выбранное состояние сна.
Заданные в неравенстве величины вычисляются следующим образом. Значение
duration рассчитывается исходя из интервала времени, на которое установлен таймеристочник внешних прерываний для планировщика процессов [7]. Это оптимистичное
предсказание времени нахождения процессорного ядра в состоянии простоя. Для того
чтобы сделать его более реальным, на основе статистики прихода внешних прерываний
рассчитывается коэффициент correction как скользящее среднее от отношения фактического значения времени сна к оптимистической оценке, вычисленного при предыдущем
простое. Если на предыдущем шаге простой продлился 50\% от оптимистической оценки,
то при вычислении скользящего среднего будет использован коэффициент 0,5. Значение
времени выхода из состояния сна latency является константой, которая задается при инициализации драйвера PMC и фиксирована для каждого аппаратно-поддержанного состояния сна. Множитель \texttt{latency\_multiplier} рассчитывается исходя из текущего состояния
средней загруженности процессорного ядра \texttt{load\_average} согласно эвристическому прави-
лу:
\texttt{latency\_multiplier} = (\texttt{load\_average} * 10) + (\texttt{num\_iowaiters} * 5),
где \texttt{num\_iowaiters} – количество процессов, ожидающих на данном процессорном ядре завершения обмена с устройством IO.
Описанный алгоритм является адаптивным и способен выбирать состояние глубоко-
го сна при слабой нагрузке вычислительного комплекса, минимизируя количество пере-
ключений в одно из состояний сна при высокой нагрузке.


\subsection{Device}
Структура содержит информацию о количестве состояний бездействия, которые поддерживаются каждым процессором, информацию о каждом из этих состояний (в массиве ) а также о состоянии этого устройства (CPU).
\lstinputlisting{device.c}

\subsection{Пользовательский интерфейс sysfs}

Следующая информация находится в /sys/devices/system/cpu/cpuidle/.

\texttt{available\_drivers} — файл только для чтения, в котором перечислены все драйверы, успешно зарегистрированные в cpuidle.

\texttt{current\_driver} — файл для чтения и записи, содержащий текущий активный cpuidle driver. Перезаписав значение этого файла на другое из списка доступных driver, меняется driver подсистемы cpuidle.

\texttt{available\_governors} является файлом только для чтения, в котором перечислены все governor, успешно зарегистрированные в cpuidle.

\texttt{current\_governor} — это файл для чтения и записи, содержащий текущий активный cpuidle governor. Перезаписав значение этого файла на другое из списка доступных governor, меняется governor подсистемы cpuidle.

Примечание для всех процессоров, в системе может быть только один governor и один driver.

Следующая информация находится в /sys/devices/system/cpu/cpuX/cpuidle/ где X --- номер ядра.

Для каждого состояния idle, поддерживаемого текущим драйвером, можно увидеть следующую информацию только для чтения под sysfs:

stateY/usage --- число случаев, когда это состояние idle было введено с момента init или redetect.

stateY/time --- время, затраченное на это состояние простоя в микросекундах. 

stateY/latency --- задержка пробуждения для данного состояния.

stateY/power --- типичная потребляемая мощность при входе устройства в это состояние в МВт.






%\lstinputlisting{e2k_clk_off.c}

\newpage
\section{Тестирование}
Тестирование проводилось на машинах e401, e801. Запускался тест \texttt{cpuidle\_menu\_tc\_test.sh}. Тест включает модуль cpuidle, меняет governor на ladder и отрабатывает в течение 30 секунд. После работы теста снимаются значения количества вхождений во все три состояния сна с каждого ядра и выводятся на экран. А также изменяется governor на rt, который не переводит ядра в состояния сна.

Как видно из результата теста, в состоянии простоя подсистема cpuidle переводит ядра, в основном, в состояние C3. В это же самое время снимались показания с провода питания ВК подключенного к 220V\textasciitilde. В режиме простоя, до включения теста, энергопотребление машины e401 составляло 50.6 Вт, а машины e801 --- 70.4 Вт. Во время работы теста энергопотребление машин составляло 41.8 Вт и 48.4 Вт.

\newpage
\section{Результаты}

\begin{itemize}
\item Реализован алгоритм перевода вычислительного ядра в состояние глубокого сна
\item Алгоритм встроен в подсистему cpuidle
\item Осуществлена возможность управления через интерфейс sysfs
\item При включении соответствующего модуля наблюдается уменьшение энергопотребления ВК e401 на 17\% в состоянии простоя 
\end{itemize}


\newpage
\section{Список литературы}


\end{document}




